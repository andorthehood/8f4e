# TODO: Implement strength reduction optimization techniques in compiler

**Priority**: ðŸŸ¡
**Estimated Effort**: 2-3 days
**Created**: 2025-01-27
**Status**: Open
**Completed**: 

## Problem Description

The compiler currently performs no strength reduction optimizations, missing opportunities to replace expensive operations with cheaper equivalent operations. Common cases include:

- What is the current state?
  - Multiplication instructions always emit WASM multiplication operations (I32_MUL, F32_MUL)
  - No detection of patterns like `x * 2` that could be optimized to `x << 1`
  - Division operations always use expensive division instructions
  - No constant folding for multiplication by 0 or 1

- Why is this a problem?
  - Multiplication and division are significantly slower than bit shift operations
  - Missing performance optimizations that modern compilers routinely apply
  - Larger bytecode size due to unoptimized instruction sequences

- What impact does it have?
  - Slower runtime performance for mathematical operations
  - Increased WASM bytecode size
  - Less competitive performance compared to optimized compiled languages

## Proposed Solution

Implement a strength reduction optimization system that detects and replaces expensive operations with cheaper equivalents:

- High-level approach:
  - Add pattern detection for common optimization opportunities
  - Replace expensive operations with equivalent cheaper operations
  - Maintain correctness while improving performance

- Key changes required:
  - Extend instruction compilers to detect optimization patterns
  - Implement constant value tracking in compilation context
  - Add optimization passes for common mathematical patterns

- Alternative approaches considered:
  1. **Instruction-level optimization**: Detect patterns during instruction compilation (immediate)
  2. **AST-level optimization**: Optimize at the abstract syntax tree level (more comprehensive)
  3. **Post-compilation optimization**: Optimize generated bytecode (separate concern)

## Implementation Plan

### Step 1: Add constant value tracking to compilation context
- Extend compilation context to track when operands are compile-time constants
- Modify stack operand types to include constant values when known
- Update instruction compilers to preserve constant information
- Expected outcome: Foundation for detecting optimization opportunities
- Dependencies: Understanding of current compilation context structure

### Step 2: Implement multiplication â†’ shift optimization
- Detect when `mul` instruction has a power-of-2 constant operand
- Replace `x * 2^n` with `x << n` using existing `shiftLeft` instruction
- Handle both integer multiplication cases
- Expected outcome: `x * 2` becomes `x << 1`, `x * 4` becomes `x << 2`, etc.
- Dependencies: Step 1 (constant tracking)

### Step 3: Implement division â†’ shift optimization  
- Detect when `div` instruction has a power-of-2 constant operand
- Replace `x / 2^n` with `x >> n` for unsigned division
- Handle signed division correctly (arithmetic right shift)
- Expected outcome: `x / 2` becomes `x >> 1`, etc.
- Dependencies: Step 1 (constant tracking)

### Step 4: Add identity and zero optimizations
- Optimize `x * 1` â†’ `x` (identity)
- Optimize `x * 0` â†’ `0` (zero)
- Optimize `x + 0` â†’ `x`
- Optimize `x - 0` â†’ `x`
- Expected outcome: Elimination of unnecessary operations
- Dependencies: Step 1 (constant tracking)

### Step 5: Add comprehensive test coverage
- Create tests for each optimization pattern
- Verify correctness of optimized vs unoptimized code
- Add performance benchmarks where applicable
- Expected outcome: Confidence in optimization correctness
- Dependencies: Steps 1-4 (optimization implementations)

## Success Criteria

- [ ] `x * 2` compiles to shift left by 1 instead of multiplication
- [ ] `x * 4` compiles to shift left by 2 instead of multiplication  
- [ ] `x / 2` compiles to shift right by 1 instead of division (unsigned)
- [ ] `x * 1` eliminates the multiplication operation entirely
- [ ] `x * 0` replaces with constant 0 push
- [ ] All existing compiler tests continue to pass
- [ ] New tests validate optimization correctness
- [ ] Documentation updated with optimization details

## Affected Components

- `packages/compiler/src/instructionCompilers/mul.ts` - Add power-of-2 detection and shift replacement
- `packages/compiler/src/instructionCompilers/div.ts` - Add division to shift optimization
- `packages/compiler/src/instructionCompilers/add.ts` - Add identity optimizations
- `packages/compiler/src/instructionCompilers/sub.ts` - Add identity optimizations
- `packages/compiler/src/types.ts` - Extend operand types to track constant values
- `packages/compiler/src/utils.ts` - Add optimization utility functions
- `packages/compiler/tests/` - Add comprehensive test coverage for optimizations

## Risks & Considerations

- **Risk 1**: Optimization correctness for edge cases (overflow, signed vs unsigned)
  - Mitigation: Comprehensive test coverage and conservative optimization rules
- **Risk 2**: Complexity increase in instruction compilers
  - Mitigation: Extract optimization logic to utility functions, maintain clean separation
- **Dependencies**: Requires understanding of WASM instruction semantics and performance characteristics
- **Breaking Changes**: None expected - optimizations should be transparent to users

## Related Items

- **Related**: Power-of-2 operations already exist (`pow2.ts` instruction)
- **Related**: Bit shift operations already implemented (`shiftLeft.ts`, `shiftRight.ts`)
- **Related**: Existing optimization infrastructure (`gaphOptimizer.ts`)

## References

- [WASM instruction reference](https://webassembly.github.io/spec/core/appendix/index-instructions.html)
- [Compiler optimization techniques](https://en.wikipedia.org/wiki/Strength_reduction)
- [LLVM strength reduction documentation](https://llvm.org/docs/WritingAnLLVMPass.html#the-strength-reduction-example)

## Notes

- Start with multiplication â†’ shift as it's the most straightforward case
- Consider performance impact of optimization detection vs runtime performance gains
- May want to add compiler flags to enable/disable optimizations for debugging
- Keep optimization logic separate from core instruction compilation for maintainability

## Archive Instructions

When this TODO is completed, move it to the `todo/archived/` folder to keep the main todo directory clean and organized.