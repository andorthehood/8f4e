---
title: 'TODO: Add map block instruction family to 8f4e'
priority: High
effort: 1-2d
created: 2026-02-21
status: Open
completed: null
---

# TODO: Add map block instruction family to 8f4e

## Problem Description

8f4e currently has no first-class instruction for value mapping in code, so users must manually build repetitive conditional chains (`if/else`) to map an input token (for example key codes or MIDI-style values) to an output value.

This creates:
- verbose and error-prone user code for a common use case,
- duplicated control-flow patterns in modules/functions,
- poor readability for declarative lookup intent.

## Proposed Solution

Add a dedicated mapping block instruction family:
- `mapBegin <inputType>`
- `map <key> <value>`
- `default <value>` (optional)
- `mapEnd <outputType>`

Agreed semantics:
- `mapBegin` opens a dedicated map block scope and stores `inputType` in compiler context.
- Between `mapBegin` and `mapEnd`, only `map` and `default` are valid.
- `map` and `default` do not emit bytecode directly; they only validate and record mapping data.
- `mapEnd` emits all bytecode for the mapping operation in one pass.
- If no `default` is present, implicit default is `0` of `<outputType>`.

Type rules:
- `mapBegin <inputType>` defines expected key/input type (`int`, `float`, `float64`).
- `mapEnd <outputType>` defines expected mapped output type (`int`, `float`, `float64`).
- Each `map` key must match `inputType`.
- Each `map` value must match `outputType`.
- `default` value (if present) must match `outputType`.
- Use existing compiler type error paths where possible (`ONLY_INTEGERS`, `ONLY_FLOATS`, mixed float-width guard path, etc.).

Runtime behavior:
- The mapping input is taken from stack at `mapEnd` compile-time lowering.
- Generated bytecode compares input against each key in declaration order.
- First matching key yields the corresponding value.
- If no key matches, return explicit `default` value or implicit `0` of `outputType`.
- Final mapped result is pushed back to stack.

Lowering strategy decision:
- Prefer branchless lowering with WebAssembly `select` (opcode `0x1B`) instead of nested `if/else` blocks.
- Use first-match-wins semantics via a `matchedLocal` integer guard.

## Anti-Patterns

- Do not emit partial bytecode in `map`; keep lowering centralized in `mapEnd`.
- Do not allow arbitrary instructions between `mapBegin` and `mapEnd`.
- Do not introduce hidden behavior for unmatched values beyond explicit/implicit default.
- Do not create a top-level `default` instruction outside map blocks.

## Implementation Plan

### Step 1: Extend compiler types/context and block model
- Add a new block type for map scope in `packages/compiler/src/types.ts` (`BLOCK_TYPE.MAP`).
- Add map-specific transient context fields to hold:
  - active map input type,
  - pending output type (from `mapEnd`),
  - collected map rows (`key`, `value`),
  - optional default value.
- Ensure this transient state is cleared on `mapEnd` and on compile errors where relevant.

### Step 2: Add instruction compilers and wire instruction registry
- Add new instruction compiler files in `packages/compiler/src/instructionCompilers/`:
  - `mapBegin.ts`
  - `map.ts`
  - `default.ts`
  - `mapEnd.ts`
- Register them in `packages/compiler/src/instructionCompilers/index.ts`.
- Keep `mapBegin`, `map`, and `default` bytecode-free except map-scope/state updates.
- Implement full lowering in `mapEnd`:
  - consume input from stack,
  - run comparison chain against collected keys,
  - produce mapped value or default/implicit zero,
  - push result stack metadata with correct type flags.
  - use branchless `select`-based assignment for each mapping row.

### Step 2.1: Add `select` opcode support in compiler internals
- Ensure `WASMInstruction` includes `SELECT = 0x1b`.
- Add any missing compiler helpers/typing paths needed to emit and type-track `select` usage in map lowering.
- Keep this internal to map lowering for now; no user-level `select` instruction is required by this TODO.

### Step 3: Enforce map-block-only instruction set
- Add validation to ensure that when inside `BLOCK_TYPE.MAP`, only `map` and `default` are accepted until `mapEnd`.
- Route invalid instructions to existing scope/block error path (`INSTRUCTION_INVALID_OUTSIDE_BLOCK`).
- Ensure `map`/`default` also reject usage outside active map block.

### Step 4: Type validation and literal/identifier handling
- Reuse existing argument parsing (`parseArgument`) and const resolution behavior.
- Validate keys/values/default against declared map input/output types.
- Support literal and const identifier forms where consistent with existing compiler conventions.
- Respect float32/float64 width distinction for map value/default typing.

### Step 5: Tests in compiler package
- Add instruction integration tests under `packages/compiler/tests/instructions/`:
  - happy paths: int->int, int->float, float->float, float64->float64.
  - implicit default `0` when `default` omitted.
  - explicit `default` override.
  - type mismatch cases for key/value/default.
  - invalid instruction inside map block.
  - `map`/`default` outside map block.
- Add/adjust lower-level unit tests in instruction compiler files as needed.

### Step 6: Editor syntax support
- Add new keywords in syntax highlighting list:
  - `mapBegin`, `map`, `default`, `mapEnd`
  - file: `packages/editor/packages/editor-state/src/features/code-editing/highlightSyntax8f4e.ts`
- Verify no parser changes needed because `instructionParser` already accepts generic instruction tokens.

### Step 7: Documentation updates
- Add map instructions to:
  - `packages/compiler/docs/instructions/control-flow.md` (or dedicated section if preferred),
  - `packages/compiler/docs/instructions.md` index list.
- Include examples for:
  - mixed input/output types,
  - default fallback behavior,
  - implicit zero fallback.
- Add explicit float-key precision note:
  - float key matching uses exact equality (`f32.eq` / `f64.eq`),
  - rounding/precision management is the user's responsibility.

## Validation Checkpoints

- `npx nx run compiler:test -- --run tests/instructions`
- `npx nx run compiler:typecheck`
- `npx nx run editor-state:test -- --run highlightSyntax8f4e` (if targeted test exists)
- `rg -n "mapBegin|mapEnd|\\bmap\\b|\\bdefault\\b" packages/compiler packages/editor`

## Success Criteria

- [ ] New instruction family compiles and runs with declared semantics.
- [ ] Only `map` and `default` are allowed inside map blocks.
- [ ] `map`/`default` emit no direct bytecode; lowering happens at `mapEnd`.
- [ ] Missing default falls back to typed zero.
- [ ] Type mismatch errors are raised via existing compiler error model.
- [ ] Compiler tests cover happy/error/default paths.
- [ ] Syntax highlighting and docs include the new instructions.

## Affected Components

- `packages/compiler/src/types.ts`
- `packages/compiler/src/withValidation.ts`
- `packages/compiler/src/instructionCompilers/index.ts`
- `packages/compiler/src/instructionCompilers/mapBegin.ts`
- `packages/compiler/src/instructionCompilers/map.ts`
- `packages/compiler/src/instructionCompilers/default.ts`
- `packages/compiler/src/instructionCompilers/mapEnd.ts`
- `packages/compiler/tests/instructions/*` (new map-related tests)
- `packages/editor/packages/editor-state/src/features/code-editing/highlightSyntax8f4e.ts`
- `packages/compiler/docs/instructions.md`
- `packages/compiler/docs/instructions/control-flow.md`

## Risks & Considerations

- **Keyword collision risk (`default`)**: ensure usage is constrained to map blocks to avoid future ambiguity with other language features.
- **Type-width correctness risk**: float32/float64 mismatch handling must align with recent float64 rules.
- **Select lowering complexity**: first-match semantics require a `matchedLocal` guard so later rows cannot override earlier matches.
- **Opcode support dependency**: map lowering depends on reliable compiler support for `select (0x1b)`.
- **Backwards compatibility**: avoid changing semantics of existing control-flow instructions.

## Branchless Lowering Notes

Target algorithm for `mapEnd` (first-match-wins, no branches):

1. Pop input into `inputLocal`.
2. Initialize `resultLocal` to explicit default or typed zero.
3. Initialize `matchedLocal` (`int`) to `0`.
4. For each map row `(key, value)`:
   - `cond = (inputLocal == key)` (i32 0/1)
   - `apply = cond AND (matchedLocal == 0)`
   - `resultLocal = select(value, resultLocal, apply)`
   - `matchedLocal = matchedLocal OR cond`
5. Push `resultLocal`.

This keeps deterministic declaration order and avoids branch-heavy lowering.

## Related Items

- **Related**: `docs/todos/262-add-f64-support-for-equal.md`
- **Related**: `docs/todos/272-add-float-width-type-guarding-to-localset.md`
- **Related**: `docs/todos/056-one-time-init-blocks-language-feature.md`

## Notes

- This TODO captures an approved design discussion before implementation.
- No code changes are included by this TODO itself.
