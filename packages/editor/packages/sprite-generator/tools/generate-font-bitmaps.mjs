#!/usr/bin/env node

/**
 * Font Bitmap Generator
 *
 * Converts ASCII art font definitions to compact Base64-encoded binary payloads.
 * This reduces bundle size by eliminating the need to ship both ASCII art and
 * the conversion logic to the client.
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '..');

/**
 * Converts a single ASCII art glyph to a numeric bitmap array.
 * Same logic as asciiToBitmap in ascii-converter.ts
 */
function asciiToBitmap(asciiGlyph, characterWidth) {
	return asciiGlyph.map(row => {
		let byte = 0;
		for (let i = 0; i < characterWidth; i++) {
			const char = i < row.length ? row[i] : ' ';
			if (char === '#') {
				byte |= 1 << (characterWidth - 1 - i);
			}
		}
		return byte;
	});
}

/**
 * Converts an array of ASCII art glyphs to a flat array of numbers.
 */
function asciiGlyphsToFont(asciiGlyphs, characterWidth) {
	return asciiGlyphs.flatMap(glyph => asciiToBitmap(glyph, characterWidth));
}

/**
 * Extracts glyphs array from a TypeScript source file.
 * This is a simple parser for the known structure of our font files.
 * 
 * Note: Uses eval() to parse the array structure, but only in a controlled
 * build-time context on trusted source files. The alternative would be a full
 * TypeScript parser which would add significant complexity.
 */
function extractGlyphsFromSource(sourceContent) {
	// Find the glyphs array declaration
	const glyphsMatch = sourceContent.match(/const glyphs = \[([\s\S]*?)\];/);
	if (!glyphsMatch) {
		throw new Error('Could not find glyphs array in source');
	}

	// Parse the glyphs - they're arrays of string arrays
	const glyphsArrayContent = glyphsMatch[1];

	// Validate that the content doesn't contain dangerous patterns
	// Block common injection patterns while allowing our expected content
	const dangerousPatterns = [
		/require\s*\(/,
		/import\s+/,
		/__dirname/,
		/__filename/,
		/process\./,
		/eval\s*\(/,
		/Function\s*\(/,
	];
	
	for (const pattern of dangerousPatterns) {
		if (pattern.test(glyphsArrayContent)) {
			throw new Error('Font source contains potentially dangerous code patterns');
		}
	}

	// Use eval in controlled context with trusted source files
	// This is safe because:
	// 1. Only runs at build time, not in browser
	// 2. Only processes our own source files
	// 3. Content is validated to not contain dangerous patterns
	// 4. Alternative (full TS parser) would add significant complexity
	const glyphs = eval(`[${glyphsArrayContent}]`);

	return glyphs;
}

/**
 * Converts a font bitmap array to Base64-encoded binary format.
 */
function fontToBase64(fontBitmap) {
	// Convert the font bitmap to a Uint8Array
	// For fonts with values > 255, we need to use Uint16Array
	const maxValue = Math.max(...fontBitmap);
	let buffer;

	if (maxValue <= 255) {
		buffer = new Uint8Array(fontBitmap);
	} else {
		// Use Uint16Array for larger values (8-bit width fonts)
		buffer = new Uint16Array(fontBitmap);
	}

	// Convert to base64
	// Node.js Buffer supports base64 encoding
	return Buffer.from(buffer.buffer).toString('base64');
}

/**
 * Generates a TypeScript module with Base64-encoded font data.
 */
function generateFontModule(fontName, characterWidth, characterHeight, base64Data, bytesPerValue) {
	return `/**
 * Generated font bitmap for ${fontName}
 * This file is auto-generated by tools/generate-font-bitmaps.mjs
 * DO NOT EDIT MANUALLY - edit the ASCII source instead and regenerate
 */

export interface FontMetadata {
	characterWidth: number;
	characterHeight: number;
	glyphCount: number;
	bytesPerValue: 1 | 2;
	base64Data: string;
}

export const fontMetadata: FontMetadata = {
	characterWidth: ${characterWidth},
	characterHeight: ${characterHeight},
	glyphCount: ${base64Data ? Math.floor(Buffer.from(base64Data, 'base64').length / bytesPerValue / characterHeight) : 0},
	bytesPerValue: ${bytesPerValue},
	base64Data: '${base64Data}',
};
`;
}

/**
 * Process a single font directory.
 */
function processFont(fontName, characterWidth, characterHeight) {
	console.log(`Processing ${fontName} font...`);

	const fontDir = join(projectRoot, 'src', 'fonts', fontName);
	const asciiPath = join(fontDir, 'ascii.ts');
	const glyphsPath = join(fontDir, 'glyphs.ts');

	// Read and parse ASCII font
	const asciiSource = readFileSync(asciiPath, 'utf-8');
	const asciiGlyphs = extractGlyphsFromSource(asciiSource);
	const asciiBitmap = asciiGlyphsToFont(asciiGlyphs, characterWidth);
	const maxAsciiValue = Math.max(...asciiBitmap);
	const asciiBytesPerValue = maxAsciiValue <= 255 ? 1 : 2;
	const asciiBase64 = fontToBase64(asciiBitmap);

	// Read and parse glyphs font
	const glyphsSource = readFileSync(glyphsPath, 'utf-8');
	const glyphsGlyphs = extractGlyphsFromSource(glyphsSource);
	const glyphsBitmap = asciiGlyphsToFont(glyphsGlyphs, characterWidth);
	const maxGlyphsValue = Math.max(...glyphsBitmap);
	const glyphsBytesPerValue = maxGlyphsValue <= 255 ? 1 : 2;
	const glyphsBase64 = fontToBase64(glyphsBitmap);

	// Generate TypeScript modules
	const asciiModule = generateFontModule(
		`${fontName}/ascii`,
		characterWidth,
		characterHeight,
		asciiBase64,
		asciiBytesPerValue
	);
	const glyphsModule = generateFontModule(
		`${fontName}/glyphs`,
		characterWidth,
		characterHeight,
		glyphsBase64,
		glyphsBytesPerValue
	);

	// Write generated files
	const outputDir = join(fontDir, 'generated');
	mkdirSync(outputDir, { recursive: true });

	writeFileSync(join(outputDir, 'ascii.ts'), asciiModule, 'utf-8');
	writeFileSync(join(outputDir, 'glyphs.ts'), glyphsModule, 'utf-8');

	console.log(`  ✓ Generated ${fontName}/generated/ascii.ts (${asciiBase64.length} base64 chars)`);
	console.log(`  ✓ Generated ${fontName}/generated/glyphs.ts (${glyphsBase64.length} base64 chars)`);

	// Return stats
	return {
		fontName,
		ascii: {
			bitmapLength: asciiBitmap.length,
			base64Length: asciiBase64.length,
			bytesPerValue: asciiBytesPerValue,
		},
		glyphs: {
			bitmapLength: glyphsBitmap.length,
			base64Length: glyphsBase64.length,
			bytesPerValue: glyphsBytesPerValue,
		},
	};
}

/**
 * Main execution.
 */
function main() {
	console.log('Font Bitmap Generator');
	console.log('=====================\n');

	const fonts = [
		{ name: '8x16', width: 8, height: 16 },
		{ name: '6x10', width: 6, height: 10 },
	];

	const stats = fonts.map(font => processFont(font.name, font.width, font.height));

	console.log('\n✓ Font generation complete!');
	console.log('\nSummary:');
	stats.forEach(({ fontName, ascii, glyphs }) => {
		console.log(`  ${fontName}:`);
		console.log(`    ASCII:  ${ascii.bitmapLength} values → ${ascii.base64Length} base64 chars`);
		console.log(`    Glyphs: ${glyphs.bitmapLength} values → ${glyphs.base64Length} base64 chars`);
	});
}

main();
